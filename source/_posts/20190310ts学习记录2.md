---
title: ts学习记录2
categories:
  - 公司教程
tags:
  - typescript
  - js
  - es6
abbrlink: 92c4c2a2
date: 2019-03-10 22:29:00
---

## 类型
TypeScript作为js的超集，具有js的一切变量类型，并另外增加了部分类型

### 基础类型
ts的基础类型和js的基础类型一致，这些类型变量在复制时是内存复制，开辟新的内存地址进行存储

- 数字 
  - number (声明方式，下同)
  - Number
- 布尔
  - boolean
  - Boolean
- 字符串
  - string
  - String
- 定义但没有值
  - null
- 未定义
  - undefined

### 复合类型/引用类型
引用类型变量在复制(非深拷贝)时是内存指针复制，不开辟新的内存地址，只是复制内存地址指针

- 对象
  - object
  - Object
  - {}
- 数组
  - Array<T>
  - T[]
  - > 可以理解为键值为连续数字的对象

### TS新增类型
新增类型在js里没有对应的类型，是ts为了增强js而增加的类型

- 任意值 
  - any
  - > 这个类型代表了任何类型值(除never外)，ts编译器编译时不会进行类型检查，同样的将不具备任何代码提示，在不知道变量类型的时候使用，不推荐
- 空值或未定义值
  - void
  - > 这个类型相当于是undefined | null的联合类型，通常是无返回值的函数的返回值定义类型  eg: (): void => {}
- 异常或永不存在的值
  - never
  - > 这个类型的是为了规定无效的函数返回值，或永不为真的变量。never是任何类型的子类，意思是任何类型的变量都可以等于返回值为never类型的函数，但是任何类型都不可赋值给never
``` typescript 
  // 例子
  let c = (): never => {
    throw new Error();
  }
  let a: number = c();
```
- 元组
  - [T, U, K]
  - > 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。当通过已知索引去获取元素的时候，会得到当前索引对应的类型，当通过超出已知索引的越界索引获取元素的时候，会得到当前元组内所有类型的联合类型
``` typescript
  let a: [string, number]; // 此时越界元素的联合类型为 string | number
  a = ['1', 1]; // 成功编译，因为和已知索引的类型对应
  a = [1, 1]; // 编译失败，因为和已知索引的类型不一致
  a = ['1', 1, 1]; // 编译失败，和已知索引类型不一致
  a[4] = 1; // 编译成功，通过越界索引获取元组类型，是符合联合类型
  a[4] = true; // 编译失败，联合类型中没有boolean
```
- 枚举
  - enum
  - > 枚举是一种数据映射

### 类型断言
通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。

> 因为在大部分js是基于浏览器运行的脚本语言，所以有时候通过获取元素的时候返回值可能是null，这个时候你要通过类型断言告诉编译器，我相信自己
``` typescript
  // 尖括号语法，vue中有时会报错，不推荐在vue-cli创建的项目中使用
  // (官方解释:当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。)
  let someValue: any = "this is a string";
  let strLength: number = (<string>someValue).length;
  // as语法
  let someValue: any = "this is a string";
  let strLength: number = (someValue as string).length;
```